/**
 * @name फ़्रीक्वेंसी मॉडुलन
 * @description <p>फ़्रीक्वेंसी मॉडुलन संश्लेषण का एक शक्तिशाली रूप है।
 * अपने सरलतम रूप में, FM में दो ऑसिलेटर शामिल होते हैं, जिन्हें संदर्भित किया जाता है
 * वाहक और न्यूनाधिक के रूप में। जैसा कि न्यूनाधिक का तरंग दोलन करता है
 * कुछ न्यूनतम और अधिकतम आयाम मान के बीच, वह क्षणिक मान
 * वाहक की आवृत्ति ("मॉड्यूलेट") में जोड़ा जाता है।</p>
 * <p><b>वाहक</b> को आमतौर पर श्रव्य आवृत्ति पर दोलन करने के लिए सेट किया जाता है
 * जिसे हम एक पिच के रूप में देखते हैं - इस मामले में, यह 220Hz पर एक साइन वेव थरथरानवाला है,
 * "A3" नोट के बराबर। वाहक डिफ़ॉल्ट रूप से मास्टर आउटपुट से जुड़ा होता है
 * (यह सभी p5.Oscillators के लिए मामला है)।</p>
 * <p>हम मास्टर आउटपुट से <b>मॉड्यूलेटर</b> को <code>डिस्कनेक्ट</code> करेंगे,
 * और इसके बजाय वाहक की आवृत्ति से कनेक्ट करें:
 * <code>carrier.freq(modulator)</code>. यह के आउटपुट आयाम को जोड़ता है
 * वाहक की आवृत्ति के लिए न्यूनाधिक।</p>
 * <p>
 * <b>मॉड्यूलेशन गहराई</b> बताती है कि वाहक आवृत्ति कितनी संशोधित करेगी।
 * यह न्यूनाधिक के आयाम पर आधारित है।
 * न्यूनाधिक आयाम मानों की एक सतत धारा उत्पन्न करता है जिसे हम जोड़ेंगे
 * वाहक आवृत्ति के लिए। शून्य के आयाम का अर्थ है मौन, इसलिए मॉडुलन होगा
 *कोई प्रभाव नहीं पड़ता। 1.0 का एक आयाम आउटपुट मानों की सीमा को मापता है
 * +1.0 और -1.0 के बीच। ध्वनि के लिए यह मानक श्रेणी है जिसे भेजा जाता है
 * आपके स्पीकर, लेकिन FM में हम इसके बजाय मॉड्यूलेटर के आउटपुट को कैरियर फ़्रीक्वेंसी पर भेज रहे हैं,
 * जहां हम मुश्किल से +1Hz / -1Hz मॉडुलन को नोटिस करेंगे।
 * तो हम आम तौर पर न्यूनाधिक के आयाम ("गहराई") को बढ़ाकर संख्याओं की तुलना में बहुत अधिक करेंगे
 * हम अपने वक्ताओं को भेज सकते हैं।</p>
 * <p><b>मॉड्यूलेशन फ़्रीक्वेंसी</b> मॉडुलन की गति है। जब मॉडुलन आवृत्ति कम होती है
 * 20 हर्ट्ज से अधिक, हम इसकी आवृत्ति को पिच के रूप में सुनना बंद कर देते हैं, और इसे धड़कन की लय के रूप में सुनना शुरू कर देते हैं।
 * उदाहरण के लिए, एक ऑपरेटिव गायक के "वाइब्रेटो" प्रभाव की नकल करने के लिए 20 की गहराई पर 7.5 हर्ट्ज़ आज़माएं।
 * इसके लिए शब्द लो फ़्रीक्वेंसी ऑसिलेटर या एलएफओ है। उच्च आवृत्तियों पर सेट किए गए मॉड्यूलेटर कर सकते हैं
 * दिलचस्प प्रभाव भी पैदा करते हैं, खासकर जब आवृत्ति का हार्मोनिक संबंध होता है
 * वाहक संकेत के लिए। उदाहरण के लिए, सुनें कि क्या होता है जब न्यूनाधिक की आवृत्ति होती है
 * वाहक का आधा या दोगुना। यह जॉन चाउनिंग द्वारा विकसित एफएम सिंथेसिस का आधार है
 * 1960 के दशक में, जो 1980 के दशक में संश्लेषण में क्रांति लाने के लिए आया था और अक्सर इसका उपयोग संश्लेषण के लिए किया जाता है
 * पीतल और घंटी जैसी आवाजें।
 *
 * <p>इस उदाहरण में,</p><p>
 * - माउसएक्स -150 से 150 तक मॉड्यूलेशन गहराई (मॉड्यूलेटर का आयाम) को नियंत्रित करता है।
 * जब मॉड्यूलेटर का आयाम 0 (बीच में) पर सेट होता है, तो ध्यान दें कि मॉड्यूलेशन कैसे होता है
 *कोई प्रभाव नहीं पड़ता। संख्या जितनी अधिक (पूर्ण मान) होगी, प्रभाव उतना ही अधिक होगा।
 * यदि मॉड्यूलेटर तरंग एक वर्ग <code>[]</code> की तरह सममित है, तो साइन <code>~</code>
 * या त्रिभुज <code>/\</code>, ऋणात्मक आयाम धनात्मक आयाम के समान होगा।
 * लेकिन इस उदाहरण में, न्यूनाधिक एक विषम चूरा तरंग है, जिसका आकार इस प्रकार है /।
 * जब हम इसे किसी ऋणात्मक संख्या से गुणा करते हैं, तो यह इस प्रकार पीछे की ओर जाती है। सबसे अच्छा के लिए
 * अंतर देखें, आवृत्ति कम करने का प्रयास करें।
 * </p>
 * <p>- MouseY न्यूनाधिक की आवृत्ति को 0 से 112 Hz तक नियंत्रित करता है।
 * श्रव्य सीमा के नीचे मॉड्यूलेशन आवृत्तियों की तुलना करने का प्रयास करें (जो लगभग 20 हर्ट्ज से शुरू होता है),
 * और इसके ऊपर, विशेष रूप से वाहक आवृत्ति के लिए एक हार्मोनिक संबंध में (जो कि 220hz है, इसलिए
 * आधा प्रयास करें, 1/3, 1/4 आदि...)।
 *
 * <p><em><span class="small">आपको इसमें शामिल करना होगा
 * <a href="http://p5js.org/reference/#/libraries/p5.sound">p5.sound लाइब्रेरी</a>
 * इस उदाहरण के लिए अपने स्वयं के प्रोजेक्ट में काम करने के लिए।</em></span></p>
 */

let carrier; // यह थरथरानवाला है जिसे हम सुनेंगे
let modulator; // यह थरथरानवाला वाहक की आवृत्ति को नियंत्रित करेगा

let analyzer; // हम इसका उपयोग तरंग की कल्पना करेंगे

// वाहक आवृत्ति पूर्व-मॉड्यूलेशन
let carrierBaseFreq = 220;

// न्यूनाधिक के लिए न्यूनतम/अधिकतम रेंजmax
let modMaxFreq = 112;
let modMinFreq = 0;
let modMaxDepth = 150;
let modMinDepth = -150;

function setup() {
  let cnv = createCanvas(800, 400);
  noFill();

  carrier = new p5.Oscillator('sine');
  carrier.amp(0); // आयाम सेट करें
  carrier.freq(carrierBaseFreq); // आवृत्ति सेट करें
  carrier.start(); // हिलना शुरू करें

  // प्रकार को 'वर्ग', 'साइन' या 'त्रिकोण' में बदलने का प्रयास करें
  modulator = new p5.Oscillator('sawtooth');
  modulator.start();

  // वाहक की आवृत्ति को संशोधित करने के लिए मॉड्यूलेटर का आउटपुट जोड़ें
  modulator.disconnect();
  carrier.freq(modulator);

  // ऑडियो का विश्लेषण करने के लिए एक FFT बनाएं
  analyzer = new p5.FFT();

  // माउसओवर / टच स्टार्ट पर वाहक को अंदर / बाहर फीका करें
  toggleAudio(cnv);
}

function draw() {
  background(30);

  // मैप माउसY अधिकतम और न्यूनतम आवृत्ति के बीच न्यूनाधिक आवृत्ति के लिए
  let modFreq = map(mouseY, height, 0, modMinFreq, modMaxFreq);
  modulator.freq(modFreq);

   // न्यूनाधिक के आयाम को बदलें
   // नकारात्मक amp चूरा तरंग को उलट देता है, और टक्कर लगता है
   //
  let modDepth = map(mouseX, 0, width, modMinDepth, modMaxDepth);
  modulator.amp(modDepth);

  // तरंग का विश्लेषण करें
  waveform = analyzer.waveform();

  // तरंग का आकार बनाएं
  stroke(255);
  strokeWeight(10);
  beginShape();
  for (let i = 0; i < waveform.length; i++) {
    let x = map(i, 0, waveform.length, 0, width);
    let y = map(waveform[i], -1, 1, -height / 2, height / 2);
    vertex(x, y + height / 2);
  }
  endShape();

  strokeWeight(1);
  // क्या हो रहा है इसके बारे में एक नोट जोड़ें
  text('Modulator Frequency: ' + modFreq.toFixed(3) + ' Hz', 20, 20);
  text(
    'Modulator Amplitude (Modulation Depth): ' + modDepth.toFixed(3),
    20,
    40
  );
  text(
    'Carrier Frequency (pre-modulation): ' + carrierBaseFreq + ' Hz',
    width / 2,
    20
  );
}

// ध्वनि को टॉगल करने के लिए सहायक कार्य
function toggleAudio(cnv) {
  cnv.mouseOver(function() {
    carrier.amp(1.0, 0.01);
  });
  cnv.touchStarted(function() {
    carrier.amp(1.0, 0.01);
  });
  cnv.mouseOut(function() {
    carrier.amp(0.0, 1.0);
  });
}
